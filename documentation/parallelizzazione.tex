Il codice sequenziale di riferimento da parallelizzare per la fase di setup è il seguente, rispettivamente per la versione c++ e python:
\lstinputlisting[language=c++, firstline=22, lastline=28,label={lst:sequential-code-setup-omp}]{BloomFilter.cpp}
\lstinputlisting[language=python, firstline=33, lastline=39,label={lst:sequential-code-setup-joblib}]{../src/bloom_filter.py}

Nella fase sequenziale della configurazione, dopo un'iniziale fase di inizializzazione finalizzata al calcolo del valore
ottimale del vettore di bit e del numero di funzioni hash in base al valore di probabilità di falsi positivi,
si procede con l'indicizzazione nel vettore di bit per ciascuna email.

Il codice sequenziale di riferimento da parallelizzare per la fase di filter è il seguente, rispettivamente per la versione c++ e python:
\lstinputlisting[language=c++, firstline=54, lastline=60,label={lst:sequential-code-filter-omp}]{BloomFilter.cpp}
\lstinputlisting[language=python, firstline=58, lastline=66,label={lst:sequential-code-filter-joblib}]{../src/bloom_filter.py}

Nella fase sequenziale del processo di filtraggio, si inizializza una variabile di conteggio per i
falsi positivi, la quale sarà incrementata ogni volta che un'email viene identificata come spam.

\subsection{OpenMP}\label{subsec:omp}
OpenMP (Omp) è una libreria in linguaggio C progettata per consentire la parallelizzazione di funzioni e cicli for.
Nel contesto di questo lavoro, abbiamo adottato la funzione \texttt{omp parallel for} per parallelizzare le operazioni
di setup e filtraggio del BloomFilter.

Successivamente, abbiamo analizzato il tempo impiegato dalle funzioni di setup e filtraggio in relazione al numero
di processi utilizzati, confrontandolo con il tempo richiesto nella versione sequenziale.
\lstinputlisting[language=c++, firstline=30, lastline=47, label={lst:openmp-setup-code}]{BloomFilter.cpp}
Per la fase di setup, abbiamo parallelizzato l'indicizzazione nel vettore di bit per ogni email, utilizzando la direttiva \texttt{omp parallel for},
e la direttiva \texttt{omp critical} per garantire l'accesso esclusivo al vettore di bit, evitando così l'accesso concorrente.

Per quanto riguarda l'operazione di filtraggio, abbiamo ideato due diverse implementazioni.
\lstinputlisting[language=c++, firstline=62, lastline=74, label={lst:openmp-filter-code}]{BloomFilter.cpp}
La prima implementazione prevede l'uso della direttiva \texttt{omp parallel for} per parallelizzare la verifica
della presenza di un'email all'interno del BloomFilter, e della direttiva \texttt{omp atomic} per garantire l'accesso esclusivo
alla variabile incrementale per il conteggio dei falsi positivi.

\lstinputlisting[language=c++, firstline=76, lastline=90, label={lst:openmp-filter2-code}]{BloomFilter.cpp}
La seconda implementazione prevede invece l'uso di una variabile incrementale per ogni thread, e la somma di queste variabili
al termine dell'operazione di filtraggio, anch'essa utilizzando la direttiva \texttt{omp atomic} per garantire l'accesso esclusivo
alla variabile incrementale globale.

Verificheremo in seguito la differenza tra queste due implementazioni.

\subsection{Joblib}\label{subsec:joblib}
Joblib è una libreria Python progettata per consentire la parallelizzazione di funzioni e cicli for.
La funzione \texttt{Parallel} accetta come input il numero di processori da impiegare e la funzione da parallelizzare.
Nell'ambito di questa ricerca, abbiamo adoperato la funzione \texttt{Parallel} per parallelizzare le operazioni di setup
e filtraggio del BloomFilter.

Successivamente, abbiamo analizzato il tempo richiesto dalle funzioni di setup e filtraggio in relazione al numero
di processi utilizzati, confrontandolo con il tempo necessario nella versione sequenziale.
\lstinputlisting[language=python, firstline=41, lastline=50,label={lst:joblib-code-setup}]{../src/bloom_filter.py}
Come nel caso di Omp, abbiamo parallelizzato l'indicizzazione nel vettore di bit per ogni email, utilizzando la funzione \texttt{Parallel},
suddividendo il vettore di email in chunk pari al numero di processi impiegati.

\lstinputlisting[language=python, firstline=68, lastline=80,label={lst:joblib-code-filter}]{../src/bloom_filter.py}
Per la fase di filtraggio, abbiamo parallelizzato la verifica della presenza di un'email all'interno del BloomFilter, utilizzando la funzione \texttt{Parallel},
suddividendo anche in questo caso il vettore di email in chunk pari al numero di processi impiegati.

Successivamente, abbiamo voluto analizzare l'effetto della dimensione del chunk anche oltre il numero di processi impiegati,
per valutare se un suo aumento potesse portare o meno un vantaggio sia in termini di tempo che di speedup.